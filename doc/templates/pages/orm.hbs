<p class="h3">Define an ORM</p>

<p class="description">
The ORM is an abstraction layer of data access. In a web use, it abstracts the ajax calls. It assurs too the integrity of data by validating them and controlling the storage. Instead of returning raw data, it builds objects and returns an instance or a collection. When calling the orm, you have to specified on which object it must be done. For example to create a likeObj instance you must write :
<p>

<pre>
orm('likeObj').create({…});
</pre>

<p class="description">
Object life
<br>
<b>orm(*).create(attributes)</b> : creates an object with the js list of attributes passed in parameter. The object is returned in output so an object method can be chained after.
<br>
<b>obj.save()</b> or <b>orm(*).save(attributes)</b> : asks to save an object on the server. If the validate function returns true the object is stored, else it is revert. The direct call from orm object bypass the object creation step so it is no recommanded.
<br>
<b>obj.remove()</b> or <b>orm(*).del(ref)</b> : removes an object locally and on server if an id is specified.
<br>
<b>orm(*).reset()</b> : removes all instances of this model.
<br>
<b>orm(*).length</b> : returns the count of instances of this model.
</p>

<p class="description">
Object retrieving
<br>
<b>orm(*).find(id, successCbk)</b> : finds the object with specified id. If it isn’t available locally, it is retrieved on server. The success callback is called with the object in parameter when it is available. If not specified, callback defined in controllers will be called.
<br>
<b>orm(*).findByRef(ref, successCbk)</b> : returns the object with specified reference. This is local reference returns at object creation so there’s no server retrieving possibility.
<br>
<b>orm(*).findByCond(cond, successCbk)</b> : finds a collection of local instances of the classes. There’s no server retrieving, it’s only a local filtering. The success callback is called with the collection in parameter when it is available. If not specified, callback defined in controllers will be called.
<br>
<b>orm(*).select(cond, successCbk [optional])</b> : finds the collection of matching objects. If the call hasn’t been done before, objects are retrieved on server, else local results are returned. The success callback is called with the collection in parameter when it is available. If not specified, callback defined in controllers will be called.
<br>
<b>orm(*).fetch(cond, successCbk [optional])</b> : finds the collection of matching objects. Objects are allways retrieved on server. It a kind of forced server call of select(). The success callback is called with the collection in parameter when it is available. If not specified, callback defined in controllers will be called.
</p>

<span class="subtitle">Specific case: html ajax call</span>
<br>
<p>
If you want to get a piece of html markup using ajax call, we recommand to use the global model "html" (call it in use dependencies using g/html).
</p>

<pre>
tetra.model.register('html', {

  req : {
	fetch : {
	  url: '{0}',
	  uriParams: ['url'],
	  parser : function(resp, col, cond) {
		col[cond.uriParams.url] = {id: cond.uriParams.url, html: resp};
		return col;
	  }
	}
  },

  attr : {
	html : ''
  },

  methods : function(attr) {
    return {
	  validate : function(attr, errors){
	     if (attr.html == '') errors.push('html');
		 return errors;
	  }
    };
  }

});
</pre>

<span class="subtitle">ORM requesting in controller</span>

<pre>
orm('html').fetch({uriParams: {url: '/path/to/page'}}).success(function(obj) {
    var markup =  obj.get('html');
});
</pre>

<span class="subtitle">ORM requesting in controller</span>

<p class="description">
This standard json format is used by the core.js framework to normalize ajax exchanges and simplify implementation on both Back-End and Front-End sides. You can see below the global definition of this format and details of how they are handled by Tetra.
</p>

<pre>
{
    "status": "SUCCESS/FAIL",
    "data": {
        4: {...},
        9: {...},
        37: {...}
    },
    "alerts": {
        "attr1": "alert message 1",
        "attr2": "alert message 2"
    },
    "errors": [
        "error message x",
        "error message y"
    ],
    "count": 3
}
</pre>

<p class="description">
<b>status</b> : Status of the response. Could take 2 values : SUCCESS or FAIL<br>
<b>data</b> : Set of object indexed by object id. Each object specifies the attributes of a result: {"id": 4, "firstName": "John", "lastName": "Doe", ...}<br>
<b>alerts</b> : Set of alert messages indexed by associated attribute. This set appears when the status is equal to FAIL but the HTTP response code is 200.<br>
<b>errors</b> : Set of error messages not indexed. This set appears when the status is equal to FAIL but the HTTP response code is different to 200.<br>
<b>count</b> (optional): The total count of available results for the request if they are paginated.
</p>

<span class="subtitle">ORM requesting in controller</span>

<p>
You can refer to these samples of awaiting response for each call type. It must help you to know which attributes you have to fill.<br>
Status 200
</p>

<pre>
{
    "status": "SUCCESS",
    "data": {
        59: {"id": 59, ...}
    }
}
</pre>

<span class="subtitle">Status code 200 with some mistaken attributes</span>

<pre>
{
    "status": "FAIL",
    "data": {
        59: {"id": 59, ...}
    },
    "alerts": {
        "attr1": "alert message 1",
        "attr2": "alert message 2"
    }
}
</pre>

<span class="subtitle">Error status codes (!=200)</span>

<pre>
{
    "status": "FAIL",
    "errors": [
        "error message x",
        "error message y"
    ]
}
</pre>