<p class="h3">Define a view</p>

<div class="code">
<pre>
tetra.view.register(name, Object)
</pre>
</div>

<p class="description">
    <b>name</b> The name of the view that is coupled to module filename. It must be the same as js file name.
    For example: if you call your view likeButton, included file will be named “likeButton.ui.js”.
</p>
<p class="description">
    <b>Object</b> This object describes view module listeners and notifiers as well as DOM handlers.
    A more detailed definition follows.
</p>

<p class="subtitle">Description</p>

<div class="code">
<pre>
{  
   scope : 'scope name',  
   use : ['controller name', ...],  
   root : 'containerId',  
   constr : function   
}
</pre>
</div>

<p class="description">

<p class="description">
    <b>scope</b> it’s the visibility scope of message sent by the view to controller. Actually this is the application scope and it must be the application name. Example: for the “like” feature, the scope could be “likeApp”.<br>
</p>
<p class="description">
    <b>use</b> the list of controllers required by the view to work properly. This list is mandatory when the view is loaded using the bootstrap feature (see below).<br>
</p>
<p class="description">
    <b>root</b> (optional) id of a root element for the view. It will limit selectors matching to this container.<br>
</p>
<p class="description">
    <b>constr</b> is a function returning view’s behaviors
</p>

<p class="subtitle">Contructor</p>

<div class="code">
<pre>
constr : function(me, app, _) { 
	return {  
     	events : {...},  
     	methods : {...}  
	};
}
</pre>
</div>

<p class="description">
    <b>me</b> this variable give you access to all data of the view object generated : scope, events, methods and all other attributes you can attach to.<br>
</p>
<p class="description">
    <b>app</b> the communication pipe to all controllers in the scope.<br>
</p>
<p class="description">
    <b>_</b> abstracted javascript library based on <a href="http://api.jquery.com" target="_blank">jQuery</a> structure with following available functions.
</p>

<p class="subtitle">Events</p>

<div class="code">
<pre>
events : {  
   user : {  
       'event name' : {  
            'selector' : function(event, element){...},  
            ...  
        },  
        ...  
   },  
   window : {  
        'event name' : function(event){...},  
         ...  
   },  
   controller : {  
        'message' : function(data){...},  
        ...  
   }  
}
</pre>
</div>

<p class="description">
<b>events</b> description of callbacks executed as a consequence of controller or user demand :<br>
</p>
<p class="description">
<b>user</b> list of events listened on the page. For each event (click, mouseover, …), we specify a list of selectors (CSS2.1 syntax) that must be reactive to this action and the function called on action. This function has access to the native event and the matched DOM element in context. e.preventDefault() is automatically call when an event match with one of the callback (except for checkbox/radio input element and keydown event). If you want to disable this behavior, add a “no-prevent” class on your element.
</p>

<p class="subtitle">Special event management:</p><br>

<p class="description">
<b>mouseover/mouseout</b> these events are cleaned. That means they work as mouseenter and mouseleave and then an element don’t catch event from its children.<br>
</p>
<p class="description">
<b>clickout</b> you can define a clickout listener for a specific selector. This callback function will be called when the user click outside a any element matching this selector. This listener only works if a click listener with the same selector is defined in the same view.
</p>

<p class="description">
<b>window</b> list of window events listened on the page. A callback function is associated to each event you want to listen.<br>
</p>
<p class="description">
<b>controller</b> list of messages sent by controllers listened in the view with the function that must executed at the reception. Datas given by controller are accessible.
</p>

<p class="subtitle">Methods</p>

<div class="code">
<pre>
methods : {  
    init : function(){...},  
    MyMethod : function(param){...},  
    ...
}
</pre>
</div>

<p class="description">
<b>init</b> is a reserved method executed when the view is registered. It can be used to define some variables accessible in the view. For example to define a DOM access, you can define a variable as an attribute attached to me : me.target = document.getElementById('targetId');<br>
Methods are common functions used locally in the view. They can be called using the me keyword.<br>
For example <b>me.methods.customMethod(data)</b> to call the function customMethod.
</p>

Sampe code ...
